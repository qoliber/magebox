package dns

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"strings"

	"github.com/qoliber/magebox/internal/platform"
)

// DnsmasqManager manages dnsmasq configuration for wildcard DNS resolution
type DnsmasqManager struct {
	platform *platform.Platform
}

// NewDnsmasqManager creates a new dnsmasq manager
func NewDnsmasqManager(p *platform.Platform) *DnsmasqManager {
	return &DnsmasqManager{platform: p}
}

// IsInstalled checks if dnsmasq is installed
func (m *DnsmasqManager) IsInstalled() bool {
	return platform.CommandExists("dnsmasq")
}

// IsConfigured checks if dnsmasq is configured for MageBox
func (m *DnsmasqManager) IsConfigured() bool {
	configPath := m.getConfigPath()
	_, err := os.Stat(configPath)
	return err == nil
}

// IsRunning checks if dnsmasq is running
func (m *DnsmasqManager) IsRunning() bool {
	cmd := exec.Command("pgrep", "dnsmasq")
	return cmd.Run() == nil
}

// Configure sets up dnsmasq to resolve *.test to localhost
func (m *DnsmasqManager) Configure() error {
	// Create config directory if needed
	configDir := m.getConfigDir()
	if err := os.MkdirAll(configDir, 0755); err != nil {
		return fmt.Errorf("failed to create config directory: %w", err)
	}

	// Write dnsmasq config
	config := m.generateConfig()
	configPath := m.getConfigPath()

	if err := m.writeConfigWithSudo(configPath, config); err != nil {
		return fmt.Errorf("failed to write dnsmasq config: %w", err)
	}

	// On macOS, also set up the resolver
	if m.platform.Type == platform.Darwin {
		if err := m.setupMacOSResolver(); err != nil {
			return fmt.Errorf("failed to setup macOS resolver: %w", err)
		}
	}

	return nil
}

// Start starts dnsmasq service
func (m *DnsmasqManager) Start() error {
	switch m.platform.Type {
	case platform.Darwin:
		cmd := exec.Command("sudo", "brew", "services", "start", "dnsmasq")
		return cmd.Run()
	case platform.Linux:
		cmd := exec.Command("sudo", "systemctl", "start", "dnsmasq")
		return cmd.Run()
	}
	return fmt.Errorf("unsupported platform")
}

// Stop stops dnsmasq service
func (m *DnsmasqManager) Stop() error {
	switch m.platform.Type {
	case platform.Darwin:
		cmd := exec.Command("sudo", "brew", "services", "stop", "dnsmasq")
		return cmd.Run()
	case platform.Linux:
		cmd := exec.Command("sudo", "systemctl", "stop", "dnsmasq")
		return cmd.Run()
	}
	return fmt.Errorf("unsupported platform")
}

// Restart restarts dnsmasq service
func (m *DnsmasqManager) Restart() error {
	switch m.platform.Type {
	case platform.Darwin:
		cmd := exec.Command("sudo", "brew", "services", "restart", "dnsmasq")
		return cmd.Run()
	case platform.Linux:
		cmd := exec.Command("sudo", "systemctl", "restart", "dnsmasq")
		return cmd.Run()
	}
	return fmt.Errorf("unsupported platform")
}

// Enable enables dnsmasq to start on boot
func (m *DnsmasqManager) Enable() error {
	switch m.platform.Type {
	case platform.Darwin:
		// brew services start already enables it
		return nil
	case platform.Linux:
		cmd := exec.Command("sudo", "systemctl", "enable", "dnsmasq")
		return cmd.Run()
	}
	return fmt.Errorf("unsupported platform")
}

// Remove removes MageBox dnsmasq configuration
func (m *DnsmasqManager) Remove() error {
	configPath := m.getConfigPath()

	if _, err := os.Stat(configPath); err == nil {
		cmd := exec.Command("sudo", "rm", configPath)
		if err := cmd.Run(); err != nil {
			return fmt.Errorf("failed to remove dnsmasq config: %w", err)
		}
	}

	// On macOS, also remove the resolver
	if m.platform.Type == platform.Darwin {
		resolverPath := "/etc/resolver/test"
		if _, err := os.Stat(resolverPath); err == nil {
			cmd := exec.Command("sudo", "rm", resolverPath)
			_ = cmd.Run() // Ignore errors - resolver may not exist
		}
	}

	return nil
}

// InstallCommand returns the command to install dnsmasq
func (m *DnsmasqManager) InstallCommand() string {
	switch m.platform.Type {
	case platform.Darwin:
		return "brew install dnsmasq"
	case platform.Linux:
		return "sudo apt install dnsmasq"
	}
	return ""
}

// getConfigDir returns the dnsmasq config directory
func (m *DnsmasqManager) getConfigDir() string {
	switch m.platform.Type {
	case platform.Darwin:
		if runtime.GOARCH == "arm64" {
			return "/opt/homebrew/etc/dnsmasq.d"
		}
		return "/usr/local/etc/dnsmasq.d"
	case platform.Linux:
		return "/etc/dnsmasq.d"
	}
	return "/etc/dnsmasq.d"
}

// getConfigPath returns the MageBox dnsmasq config file path
func (m *DnsmasqManager) getConfigPath() string {
	return filepath.Join(m.getConfigDir(), "magebox.conf")
}

// generateConfig generates the dnsmasq configuration
func (m *DnsmasqManager) generateConfig() string {
	var sb strings.Builder

	sb.WriteString("# MageBox DNS Configuration\n")
	sb.WriteString("# Routes *.test domains to localhost\n")
	sb.WriteString("# Generated by MageBox - do not edit manually\n\n")

	// Route .test TLD to localhost
	sb.WriteString("address=/test/127.0.0.1\n")

	// Additional local TLDs you might want
	sb.WriteString("address=/localhost/127.0.0.1\n")

	// Listen only on localhost (for security)
	sb.WriteString("\n# Security settings\n")
	sb.WriteString("listen-address=127.0.0.1\n")
	sb.WriteString("bind-interfaces\n")

	return sb.String()
}

// writeConfigWithSudo writes config file using sudo
func (m *DnsmasqManager) writeConfigWithSudo(path, content string) error {
	// Write to temp file first
	tmpFile, err := os.CreateTemp("", "dnsmasq-*.conf")
	if err != nil {
		return err
	}
	tmpPath := tmpFile.Name()
	defer os.Remove(tmpPath)

	if _, err := tmpFile.WriteString(content); err != nil {
		tmpFile.Close()
		return err
	}
	tmpFile.Close()

	// Copy to destination with sudo
	cmd := exec.Command("sudo", "cp", tmpPath, path)
	return cmd.Run()
}

// setupMacOSResolver sets up the macOS resolver for .test domain
func (m *DnsmasqManager) setupMacOSResolver() error {
	// Create /etc/resolver directory
	cmd := exec.Command("sudo", "mkdir", "-p", "/etc/resolver")
	if err := cmd.Run(); err != nil {
		return fmt.Errorf("failed to create resolver directory: %w", err)
	}

	// Create resolver config for .test
	resolverContent := "nameserver 127.0.0.1\n"

	tmpFile, err := os.CreateTemp("", "resolver-test-*")
	if err != nil {
		return err
	}
	tmpPath := tmpFile.Name()
	defer os.Remove(tmpPath)

	if _, err := tmpFile.WriteString(resolverContent); err != nil {
		tmpFile.Close()
		return err
	}
	tmpFile.Close()

	// Copy to /etc/resolver/test
	cmd = exec.Command("sudo", "cp", tmpPath, "/etc/resolver/test")
	return cmd.Run()
}

// TestResolution tests if DNS resolution is working for .test domains
func (m *DnsmasqManager) TestResolution(domain string) bool {
	cmd := exec.Command("dig", "+short", domain, "@127.0.0.1")
	output, err := cmd.Output()
	if err != nil {
		return false
	}
	return strings.Contains(string(output), "127.0.0.1")
}

// Status returns the current dnsmasq status
type DnsmasqStatus struct {
	Installed  bool
	Configured bool
	Running    bool
	TestDomain string
	Resolving  bool
}

// GetStatus returns the current dnsmasq status
func (m *DnsmasqManager) GetStatus() DnsmasqStatus {
	status := DnsmasqStatus{
		Installed:  m.IsInstalled(),
		Configured: m.IsConfigured(),
		Running:    m.IsRunning(),
		TestDomain: "test.test",
	}

	if status.Running {
		status.Resolving = m.TestResolution(status.TestDomain)
	}

	return status
}
